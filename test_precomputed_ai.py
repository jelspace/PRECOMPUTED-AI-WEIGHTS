# -----------------------------------------------------------------------------
# test_precomputed_ai.py
# -----------------------------------------------------------------------------
# This script is responsible for testing the functionality of the
# `precomputed_ai_weights` module. It loads a sample precomputed database
# (expected to be in `sample_database.json`, generated by
# `generate_sample_database.py`) and then runs various test cases against
# the `simulate_neuron` function.
#
# Test cases include:
# - Valid inputs that should exist in the database.
# - Inputs that should not exist (e.g., values out of the defined bit depth).
# - Invalid input types (e.g., list instead of tuple).
# - Inputs with an incorrect number of parameters.
#
# The script prints whether each test passes or fails, providing a basic
# mechanism for verifying the correctness of the core simulation logic.
# -----------------------------------------------------------------------------

import json
from precomputed_ai_weights import simulate_neuron

def load_database(filename="sample_database.json"):
    """
    Loads the precomputed database from the specified JSON file.
    The database is expected to have stringified tuple keys (e.g., "(0, 0)").
    """
    try:
        with open(filename, 'r') as f:
            # The database loaded from JSON will have string keys like "(0, 0)"
            database = json.load(f)
        print(f"Database '{filename}' loaded successfully. Contains {len(database)} entries.")
        return database
    except FileNotFoundError:
        print(f"Error: Database file '{filename}' not found. Please run generate_sample_database.py first.")
        return None
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{filename}'.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred while loading the database: {e}")
        return None

def run_test(test_name, database, input_values, expected_output, expect_error=None):
    """Runs a single test case for simulate_neuron."""
    print(f"\n--- {test_name} ---")
    print(f"Input: {input_values}")

    try:
        result = simulate_neuron(database, input_values)
        if expect_error:
            print(f"Test FAILED: Expected error {expect_error}, but got result {result}")
        elif result == expected_output:
            print(f"Test PASSED: Output {result} matches expected {expected_output}")
        else:
            print(f"Test FAILED: Output {result}, Expected {expected_output}")
    except Exception as e:
        if expect_error and isinstance(e, expect_error):
            print(f"Test PASSED: Correctly raised {type(e).__name__}: {e}")
        elif expect_error:
            print(f"Test FAILED: Expected error {expect_error}, but got {type(e).__name__}: {e}")
        else:
            print(f"Test FAILED: Unexpected error {type(e).__name__}: {e}")

def main():
    # --- Load the Sample Database ---
    # The `sample_database.json` is expected to be generated by `generate_sample_database.py`.
    # For the default parameters used in that script (num_inputs=2, input_bit_depth=2, operation="multiply"):
    # - Each input can range from 0 to (2^2 - 1) = 3.
    # - Input combinations will be for (x,y) where x,y are in {0,1,2,3}.
    # - Keys in the JSON database are string representations of these tuples, e.g., "(1, 1)".
    # - Values are the results of the "multiply" operation (e.g., for "(2,3)" the value is 6).
    database = load_database()
    if database is None:
        print("Halting tests due to database loading failure.")
        return

    # --- Test Cases Definition ---
    # Each test case calls `run_test` which in turn calls `simulate_neuron`
    # and checks its output or raised exceptions against expected values.
    # Expected results for valid inputs are based on the "multiply" operation.

    # Test 1: Input (1, 1). Expected multiplication result: 1 * 1 = 1.
    # This is a basic test for a successful lookup of a valid input combination.
    run_test("Test Valid Input (1,1)", database, (1, 1), 1)

    # Test 2: Input (2, 3). Expected multiplication result: 2 * 3 = 6.
    # Tests with different, non-zero, non-one input values.
    run_test("Test Valid Input (2,3)", database, (2, 3), 6)

    # Test 3: Input (3, 2). Expected multiplication result: 3 * 2 = 6.
    # Verifies that the order of inputs (for a commutative operation like multiply)
    # is handled correctly if keys are stored consistently (which they are: str(tuple) is order-dependent).
    run_test("Test Valid Input (3,2)", database, (3, 2), 6)

    # Test 4: Input (0, 2). Expected multiplication result: 0 * 2 = 0.
    # Tests handling of zero as one of the inputs.
    run_test("Test Valid Input (0,2)", database, (0, 2), 0)

    # Test 5: Input (3, 3). Expected multiplication result: 3 * 3 = 9.
    # Tests inputs at their maximum value as defined by input_bit_depth=2 (values 0,1,2,3).
    run_test("Test Valid Input (3,3)", database, (3, 3), 9)

    # Test 6: Input (5, 5). These values are outside the defined bit depth range (0-3 for bit_depth=2).
    # `simulate_neuron` (via `query_database`) should raise a KeyError because
    # the string key "(5, 5)" will not exist in the database generated with input_bit_depth=2.
    run_test("Test Invalid Input (5,5) - Values Out of Range", database, (5, 5), None, expect_error=KeyError)

    # Test 7: Input (1, 5). One value (5) is out of the defined bit depth range.
    # Similar to Test 6, this should result in a KeyError.
    run_test("Test Invalid Input (1,5) - One Value Out of Range", database, (1, 5), None, expect_error=KeyError)

    # Test 8: Input [1,1] - using a list instead of a tuple for input_values.
    # The `query_database` function explicitly checks for `isinstance(input_values, tuple)`
    # and should raise a TypeError.
    run_test("Test Invalid Input Type (list [1,1])", database, [1,1], None, expect_error=TypeError)

    # Test 9: Input (1,2,3) - a tuple with 3 elements.
    # The sample database was generated for num_inputs=2.
    # Therefore, the key "(1, 2, 3)" will not be found. This should result in a KeyError.
    run_test("Test Invalid Input (1,2,3) - Wrong Number of Inputs for Database", database, (1,2,3), None, expect_error=KeyError)


if __name__ == "__main__":
    main()
